% SID: 310182212
% Name: Tianyu Pu
\documentclass[12pt]{article}
\usepackage{emph}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{natbib}
\usepackage{hyperref}
\usepackage{fullpage}
\pagestyle{fancy}
\rhead{Tianyu Pu 310182212}

\title{COMP3520 Assignment 2\\
  HOST Dispatcher Design Document}
\author{Tianyu Pu\\
  310182212}
\date{Semester 1, 2012}
\fancyhead[R]{310182212}

\begin{document}
\maketitle

\section{Introduction}
In this report we shall examine the Hypothetical Operating System Testbed
(HOST) Dispatcher, starting wih a discussion of memory allocation
algorithms as well as data structures for the memory and resources, the overall
structure of the dispatcher, and concluding with a discussion and comparison
of the dispatching schemes of HOST and real operating systems.

\section{Memory allocation}
For the purposes of the assignment, the memory used by the processes is a
contiguous block of memory assigned to that process for the entire lifetime of
that process. The system only has 1024 megabytes (MB) of memory available for
processes, and 64 MB must always be available for real-time processes -- this
leaves 960 MB available for all active user jobs.

In addition, there is no virtual memory support, nor is the system paged.

Within these constraints, a number of variable memory partitioning algorithms
are possible. The most commonly used are described below.

\subsection{Overview of memory allocation algorithms}
The need for memory management becomes apparent in a multiprogramming system
such as the HOST dispatcher. This is because in addition to a ``system" part
of memory, the ``user" part must also be divided to allow for multiple
processes. In order to implement this, we examine some of the ways in which
memory can be dynamically partitioned. Dynamic partitioning (i.e. allocating
to a process exactly how much memory it needs) was considered over
fixed partitioning (i.e. allocating a fixed block of memory to a process which
may be more than it needs, effectively wasting the extra memory) because it
more efficiently utilised the limited memory resources available in the HOST
dispatcher.

As stated earlier, dynamic partitioning involves allocating to a process
exactly how much memory it requires. Over time, as more and more processes
are created and more memory is allocated and recycled, we end up with many
small holes in memory, a phenomenon known as \textit{external fragmentation}.
It then follows that if we carefully choose which section of memory to allocate
to a process we can reduce the number of these so-called fragments. With this
context we will consider three different ways of placing these partitions,
best-fit, first-fit, and next-fit -- these are called placement algorithms.
In addition, the buddy system will also be described.

\subsubsection{Placement algorithms -- best-fit, first-fit, next-fit}
These three algorithms are all limited to selecting from the free blocks of
memory that are equal or larger than the memory that the process about to be
run needs.

\textit{Best-fit} selects the free block that is as close to the required size
as possible. \textit{First-fit} starts from the beginning of the block and
selects the first free block that is large enough (regardless of how large or
small the difference in size is), and \textit{next-fit} is like first-fit
except that it scans from the place of the last allocation instead of at the
beginning every time.

\subsubsection{Buddy system}
The buddy system is an attempt to compromise between the fixed and dynamic
partitioning schemes. Firstly, the size of the smallest possible memory block
that can be allocated is determined. (This can depend on actual hardware
limitations or on a balance between reducing memory wastage and excessive
maintenance overhead). Then, the entire space available for allocation is
treated as a single block of size $2^N$. If a request of size $s$ is less
than $2^N$ and greater than $2^{N-1}$ (half of the block), then the entire
block is allocated. If not, the block is split into two ``buddies" of size
$2^{N-1}$ and the request is allocated to one of these buddies. Now, if 
this request is less than the size of the block $2^{N-1}$
but greater than $2^{N-2}$ (i.e., half of one of the buddy blocks), the process
is allocated to one of the buddies. Otherwise, similar to the previous
allocation, one of the buddies is split in half. This goes on until the
process is allocated.

\subsection{Justification of final choice}
The final memory allocation system used in the HOST dispatcher is the first-fit
placement algorithm. There are a number of reasons why this algorithm was
chosen over the others discussed above.

Of course, out of the three placement algorithm choices that are possible, the
one that is best will depend on the size and swapping sequence of processes.
However, \cite{stallings:2012} gathers and presents some general comments that
have been made about these algorithms: first-fit tends to be the best and
fastest; next-fit performs slightly worse as it tends to leave many fragments
at the end of the block of free space, requiring more frequent merging of
adjacent free blocks (\textit{compaction}) that incur a lot of overhead; and
best-fit is usually the worst performer, as it leaves behind many blocks too
small to satisfy subsequent allocation requests due to the fact that it tries
to guarantee that the remaining free space after allocation is as small as
possible (and hence requiring a great deal of memory compaction).

\section{Data structures}

\subsection{Queuing}

\subsection{Dispatching}

\subsection{Allocating}

\section{Program structure}

\subsection{Overview}

\subsection{\tt{hostd.c}}

\subsection{\tt{pcb.c}}

\subsection{\tt{mab.c}}

\subsection{\tt{rsrc.c}}

\section{Dispatching schemes}

\subsection{Dispatching scheme of the scheduler}

\subsection{Schemes used by popular operating systems}

\subsection{Discussion}

\section{Concluding remarks}

\bibliographystyle{plainnat}
\bibliography{report}

\end{document}
